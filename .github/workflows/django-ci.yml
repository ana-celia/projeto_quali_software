name: Django CI

on:
  push:
    branches: ['**']
  pull_request:
    branches: ['**']

jobs:
  duplicate-check:
    name: "ðŸ” Detector de CÃ³digo Duplicado"
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-python@v5
      with:
        python-version: '3.12'

    - name: Instalar radon
      run: pip install radon

    - name: Verificar duplicaÃ§Ã£o no cÃ³digo real
      run: |
        cd artesanato
        echo "=== DETECTOR DE CÃ“DIGO DUPLICADO ==="
        echo "ðŸ” Analisando: api/"
        radon raw api/ --min D 2>&1 | grep -B1 -A1 "duplicate\|similar" && exit 1 || echo "âœ… NENHUMA DUPLICAÃ‡ÃƒO ENCONTRADA - CÃ³digo limpo!"

  code-smells-check:
    name: "ðŸ‘ƒ Detector de Code Smells"
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-python@v5
      with:
        python-version: '3.12'

    - name: Instalar ferramentas de anÃ¡lise
      run: |
        pip install pylint pylint-django radon

    - name: Executar anÃ¡lise automÃ¡tica de code smells
      run: |
        cd artesanato
        
        echo "ðŸš€ INICIANDO ANÃLISE AUTOMÃTICA DE CODE SMELLS"
        echo "=============================================="
        
        # Configurar Django
        export DJANGO_SETTINGS_MODULE="artesanato.settings"
        export PYTHONPATH="$PWD:$PYTHONPATH"
        
        # 1. EXECUTAR ANÃLISE E COLETAR RESULTADOS
        echo -e "\nðŸ” EXECUTANDO ANÃLISE COM PYLINT..."
        pylint --load-plugins pylint_django api/ > /tmp/full_analysis.txt 2>&1 || true
        
        # 2. GERAR DADOS EM JSON PARA ANÃLISE
        echo -e "\nðŸ“Š PROCESSANDO RESULTADOS..."
        pylint --load-plugins pylint_django --output-format=json api/ > /tmp/pylint_results.json 2>/dev/null || true
        
        # 3. IDENTIFICAR OS 3 PRINCIPAIS CODE SMELLS AUTOMATICAMENTE
        echo -e "\nðŸŽ¯ IDENTIFICANDO OS 3 CODE SMELLS MAIS FREQUENTES..."
        
        python3 -c "
        import json
        import collections
        import re

        try:
            # Ler resultados do Pylint
            with open('/tmp/pylint_results.json', 'r') as f:
                data = json.load(f)
            
            if not data:
                print('âœ… Nenhum code smell encontrado pelo Pylint!')
                
                # Mostrar anÃ¡lise completa de qualquer forma
                print('\nðŸ“„ AnÃ¡lise completa:')
                with open('/tmp/full_analysis.txt', 'r') as f:
                    print(f.read()[:1000] + '...' if len(f.read()) > 1000 else f.read())
                
                exit(0)
            
            # Contar frequÃªncia de cada tipo de code smell
            counts = collections.Counter(item['symbol'] for item in data)
            
            print(f'ðŸ“ˆ Total de code smells detectados: {len(data)}')
            print(f'ðŸ” Tipos distintos de code smells: {len(counts)}')
            
            # Obter os 3 mais frequentes
            top_3 = counts.most_common(3)
            
            print('\n' + '='*60)
            print('ðŸ† TOP 3 CODE SMELLS MAIS FREQUENTES NO PROJETO:')
            print('='*60)
            
            # Mapear cÃ³digos para descriÃ§Ãµes amigÃ¡veis
            code_descriptions = {
                'R0901': 'Too many ancestors - Muita heranÃ§a de classes',
                'R0902': 'Too many instance attributes - Muitos atributos na classe',
                'R0903': 'Too few public methods - Poucos mÃ©todos pÃºblicos',
                'R0912': 'Too many branches - Muitos if/else/switch',
                'R0913': 'Too many arguments - MÃ©todo com muitos parÃ¢metros',
                'R0914': 'Too many local variables - Muitas variÃ¡veis locais',
                'R0915': 'Too many statements - MÃ©todo muito longo',
                'C0103': 'Invalid name - Nome nÃ£o segue convenÃ§Ã£o',
                'C0114': 'Missing module docstring - Falta docstring no mÃ³dulo',
                'C0115': 'Missing class docstring - Falta docstring na classe',
                'C0116': 'Missing function docstring - Falta docstring na funÃ§Ã£o',
                'C0301': 'Line too long - Linha muito longa',
                'C0303': 'Trailing whitespace - EspaÃ§os em branco no final da linha',
                'C0304': 'Missing final newline - Falta nova linha no final',
                'W0611': 'Unused import - Import nÃ£o utilizado',
                'W0612': 'Unused variable - VariÃ¡vel nÃ£o utilizada',
                'W0613': 'Unused argument - Argumento nÃ£o utilizado',
                'E0401': 'Unable to import - NÃ£o consegue importar mÃ³dulo',
                'E1101': 'Nonexistent member - Membro nÃ£o existente',
            }
            
            for i, (symbol, count) in enumerate(top_3, 1):
                description = code_descriptions.get(symbol, 'Code smell nÃ£o catalogado')
                print(f'\n{i}Âº - {symbol}: {description}')
                print(f'   ðŸ“ OcorrÃªncias: {count}')
                
                # Mostrar alguns exemplos deste code smell
                examples = [item for item in data if item['symbol'] == symbol][:2]
                for ex in examples:
                    filename = ex['path'].split('/')[-1]
                    print(f'   ðŸ“„ {filename}:{ex[\"line\"]} - {ex[\"message\"]}')
    
        # 4. MOSTRAR OUTRAS ESTATÃSTICAS
        print('\n' + '='*60)
        print('ðŸ“ˆ ESTATÃSTICAS COMPLETAS:')
        print('='*60)
        
        # Agrupar por categoria
        categories = collections.defaultdict(int)
        for symbol, count in counts.items():
            # Extrair categoria (primeira letra + nÃºmero)
            match = re.match(r'([A-Z])(\d+)', symbol)
            if match:
                category = match.group(1)
                if category == 'R':
                    categories['Refactor'] += count
                elif category == 'C':
                    categories['Convention'] += count
                elif category == 'W':
                    categories['Warning'] += count
                elif category == 'E':
                    categories['Error'] += count
                elif category == 'F':
                    categories['Fatal'] += count
                else:
                    categories['Other'] += count
            else:
                categories['Other'] += count
        
        print('\nðŸ“‹ DistribuiÃ§Ã£o por categoria:')
        for category, count in sorted(categories.items()):
            print(f'   â€¢ {category}: {count} code smells')
        
        # Score do Pylint
        if data:
            last_item = data[-1]
            if 'type' in last_item and last_item['type'] == 'score':
                score = last_item['message'].split(' ')[-1].replace('/10', '')
                print(f'\nâ­ Score do Pylint: {score}/10')
        
        # 5. RECOMENDAÃ‡Ã•ES BASEADAS NOS RESULTADOS
        print('\n' + '='*60)
        print('ðŸ’¡ RECOMENDAÃ‡Ã•ES DE CORREÃ‡ÃƒO:')
        print('='*60)
        
        recommendations = {
            'R0901': 'Considere reduzir a cadeia de heranÃ§a ou usar composiÃ§Ã£o.',
            'R0902': 'Refatore classes grandes em classes menores (Single Responsibility).',
            'R0903': 'Classes devem ter comportamentos pÃºblicos claros.',
            'R0913': 'Quebre mÃ©todos com muitos parÃ¢metros em mÃ©todos menores.',
            'R0915': 'MÃ©todos muito longos sÃ£o difÃ­ceis de manter. Extraia funÃ§Ãµes.',
            'C0103': 'Siga as convenÃ§Ãµes de nomenclatura (snake_case para funÃ§Ãµes/variÃ¡veis).',
            'C0114': 'Adicione docstrings para documentar mÃ³dulos importantes.',
            'C0301': 'Quebre linhas muito longas para melhor legibilidade.',
            'W0611': 'Remova imports nÃ£o utilizados para limpar o cÃ³digo.',
            'W0612': 'VariÃ¡veis nÃ£o utilizadas podem indicar cÃ³digo morto.',
        }
        
        for symbol, _ in top_3:
            if symbol in recommendations:
                print(f'   â€¢ Para {symbol}: {recommendations[symbol]}')
        
        print('\n' + '='*60)
        print('âœ… ANÃLISE COMPLETA CONCLUÃDA')
        print('='*60)
        
    except Exception as e:
        print(f'âš ï¸  Erro ao processar anÃ¡lise: {e}')
         print('\nðŸ“„ Resultado bruto da anÃ¡lise:')
        with open('/tmp/full_analysis.txt', 'r') as f:
            content = f.read()
            print(content[:1500] + '...' if len(content) > 1500 else content)
            echo -e "\n==========================================="
            echo "ðŸŽ¯ ANÃLISE DE CODE SMELLS CONCLUÃDA"
            echo "==========================================="
      lint:
        name: "ðŸ“ AnÃ¡lise de CÃ³digo"
        runs-on: ubuntu-latest
        needs: code-smells-check

        steps:
        - uses: actions/checkout@v4
        - uses: actions/setup-python@v5
          with:
            python-version: '3.12'

        - name: Instalar dependÃªncias do projeto
          run: |
            cd artesanato
            pip install -r requirements.txt

        - name: Verificar estilo PEP 8 com flake8
          run: |
            cd artesanato
            pip install flake8
            flake8 . --count --statistics

      test:
        name: "ðŸ§ª Testes"
        runs-on: ubuntu-latest
        needs: lint

        services:
          postgres:
            image: postgres:15
            env:
              POSTGRES_PASSWORD: 9061
              POSTGRES_DB: artesanato
            options: >-
              --health-cmd pg_isready
              --health-interval 10s
              --health-timeout 5s
              --health-retries 5
            ports:
              - 5432:5432

        steps:
        - uses: actions/checkout@v4
        - uses: actions/setup-python@v5
          with:
            python-version: '3.12'

        - name: Instalar dependÃªncias
          run: |
            cd artesanato
            pip install -r requirements.txt

        - name: Rodar migraÃ§Ãµes
          run: |
            cd artesanato
            python manage.py migrate
          env:
            DATABASE_URL: postgresql://postgres:9061@localhost:5432/artesanato

        - name: Rodar testes
          run: |
            cd artesanato
            python manage.py test
          env:
            DATABASE_URL: postgresql://postgres:9061@localhost:5432/artesanato

        - name: Verificar sintaxe Django
          run: |
            cd artesanato
            python manage.py check

  uml-diagram:
    name: "ðŸ“Š Gerar Diagrama UML"
    runs-on: ubuntu-latest
    needs: test

    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-python@v5
      with:
        python-version: '3.12'

    - name: Instalar Graphviz
      run: sudo apt-get update && sudo apt-get install -y graphviz

    - name: Instalar dependÃªncias Python
      run: |
        cd artesanato
        pip install -r requirements.txt django-extensions pydotplus

    - name: Gerar diagrama UML
      run: |
        cd artesanato

        # Configurar Django
        export DJANGO_SETTINGS_MODULE="artesanato.settings"
        export PYTHONPATH="$PWD:$PYTHONPATH"

        # Criar diretÃ³rio
        mkdir -p docs

        # Gerar diagrama
        echo "ðŸ“Š Gerando diagrama UML com pydotplus..."
        python manage.py graph_models api \
          --output docs/class_diagram.png \
          --theme django2018 \
          --group-models \
          --arrow-shape normal

        # Verificar se gerou
        if [ -f "docs/class_diagram.png" ]; then
          echo "âœ… Diagrama gerado com sucesso!"
          ls -la docs/class_diagram.png
        else
          echo "âš ï¸  NÃ£o gerou PNG, tentando formato DOT..."
          python manage.py graph_models api --dot > docs/class_diagram.dot
          dot -Tpng docs/class_diagram.dot -o docs/class_diagram.png
        fi

    - name: Upload diagrama
      uses: actions/upload-artifact@v4
      with:
        name: uml-diagram
        path: artesanato/docs/class_diagram.png